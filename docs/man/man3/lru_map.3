.TH "lru_map" 3 "21 Feb 2013" "p2p-distrubuted" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lru_map \- Template header for \fBlru_map\fP ADT.  

.PP
.SH SYNOPSIS
.br
.PP
\fC#include <lru_map.hh>\fP
.PP
Inherits \fBdictionary< key, value >< key, value >\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBlru_map\fP (size_t _max)"
.br
.ti -1c
.RI "bool \fBinsert\fP (const key &, const value &)"
.br
.RI "\fIPush back in the linked list the given value and store the key and the address of that value in the hash table. In case that the pair is already in the list it will be moved to the newest position. \fP"
.ti -1c
.RI "void \fBpop\fP (void)  throw (out_of_range)"
.br
.RI "\fIRemove the older element of the list and its reference in the hash table. \fP"
.ti -1c
.RI "const value & \fBlookup\fP (const key &)  throw (out_of_range)"
.br
.RI "\fIThis method will search the value of the given key. If it is found, It will remove the element and push into the last position of the list, e.g. the newest element. \fP"
.ti -1c
.RI "const value & \fBoldest\fP (void)  throw (out_of_range)"
.br
.ti -1c
.RI "const value & \fBnewest\fP (void)  throw (out_of_range)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBupdate\fP (const key &, const value &)  throw (out_of_range)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "size_t \fBmax\fP"
.br
.ti -1c
.RI "list< pair< key, value > > \fBll\fP"
.br
.ti -1c
.RI "\fBhashTable\fP< key, typename list< pair< key, value > >::iterator > \fBht\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<class key, class value> class lru_map< key, value >"
Template header for \fBlru_map\fP ADT. 

\fBSee also:\fP
.RS 4
\fBhashTable\fP <\fBhashtable.hh\fP> 
.RE
.PP
\fBAuthor:\fP
.RS 4
Vicente Adolfo Bolea Sanchez <vicente.bolea@gmail.com>, <vicente@unist.ac.kr>
.RE
.PP
.SH "DESCRIPTION"
.PP
This is just a sketch for the LRU map class.
.SS "COMPLEXITY"
Here is described the time complexities of each functions:
.IP "\(bu" 2
insert: O(1) (amortized time)
.IP "\(bu" 2
lookup: O(1)
.IP "\(bu" 2
oldest: O(1)
.IP "\(bu" 2
newest: O(1)
.IP "\(bu" 2
pop: O(1)
.PP
.PP
These complexities will be in the best case since the hash table will may rehash sometimes and in each rehash it will take O(n + buckets).
.SS "METHODOLOGY"
This Lru map is using a hashtable+doublylinkedlist where:
.IP "\(bu" 2
The hash table will store a pointer of each element in the list.
.IP "\(bu" 2
The linkedlist will be use as lru linkedlist with a pair of key and value.
.PP
.SS "TODO"
Here is the way that I am implementing this LRU:
.IP "\(bu" 2
The LL will just store the diskpage.
.PP
.PP
.IP "\(bu" 2
The hash table given a key (wish in this experiment will be a set of number) will store pointers to each node of the LL. 
.PP

.PP
.SH "Member Function Documentation"
.PP 
.SS "template<class key, class value> bool \fBlru_map\fP< key, value >::insert (const key & k, const value & v)\fC [virtual]\fP"
.PP
Push back in the linked list the given value and store the key and the address of that value in the hash table. In case that the pair is already in the list it will be moved to the newest position. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP value 
.br
\fIv\fP paired with the previous key 
.RE
.PP

.PP
Implements \fBdictionary< key, value >\fP.
.SS "template<class key, class value> const value & \fBlru_map\fP< key, value >::lookup (const key & k)  throw (out_of_range)\fC [virtual]\fP"
.PP
This method will search the value of the given key. If it is found, It will remove the element and push into the last position of the list, e.g. the newest element. 
.PP
\fBParameters:\fP
.RS 4
\fIk\fP key 
.RE
.PP
\fBReturns:\fP
.RS 4
tmp value paired with the given key 
.RE
.PP

.PP
Implements \fBdictionary< key, value >\fP.
.SS "template<class key, class value> const value & \fBlru_map\fP< key, value >::newest (void)  throw (out_of_range)"
.PP
\fBReturns:\fP
.RS 4
The oldest element of the LRU_map 
.RE
.PP

.SS "template<class key, class value> const value & \fBlru_map\fP< key, value >::oldest (void)  throw (out_of_range)"
.PP
\fBReturns:\fP
.RS 4
The oldest element of the LRU_map 
.RE
.PP

.SS "template<class key, class value> void \fBlru_map\fP< key, value >::update (const key & k, const value & v)  throw (out_of_range)\fC [protected]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIk\fP value 
.br
\fIv\fP paired with the previous key 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for p2p-distrubuted from the source code.
